{"id":"../../node_modules/axios/lib/adapters/fetch.js","dependencies":[{"name":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\package.json","includedInParent":true,"mtime":1763386662470},{"name":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\package.json","includedInParent":true,"mtime":1762179839857},{"name":"../platform/index.js","loc":{"line":1,"column":21,"index":21},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\platform\\index.js"},{"name":"../utils.js","loc":{"line":2,"column":18,"index":63},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\utils.js"},{"name":"../core/AxiosError.js","loc":{"line":3,"column":23,"index":101},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\core\\AxiosError.js"},{"name":"../helpers/composeSignals.js","loc":{"line":4,"column":27,"index":153},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\helpers\\composeSignals.js"},{"name":"../helpers/trackStream.js","loc":{"line":5,"column":26,"index":211},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\helpers\\trackStream.js"},{"name":"../core/AxiosHeaders.js","loc":{"line":6,"column":25,"index":265},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\core\\AxiosHeaders.js"},{"name":"../helpers/progressEventReducer.js","loc":{"line":7,"column":75,"index":367},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\helpers\\progressEventReducer.js"},{"name":"../helpers/resolveConfig.js","loc":{"line":8,"column":26,"index":431},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\helpers\\resolveConfig.js"},{"name":"../core/settle.js","loc":{"line":9,"column":19,"index":481},"parent":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\adapters\\fetch.js","resolved":"C:\\Users\\User\\Desktop\\complete-node-bootcamp-master\\4-natours\\starter\\node_modules\\axios\\lib\\core\\settle.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFetch = exports.default = void 0;\nvar _index = _interopRequireDefault(require(\"../platform/index.js\"));\nvar _utils = _interopRequireDefault(require(\"../utils.js\"));\nvar _AxiosError = _interopRequireDefault(require(\"../core/AxiosError.js\"));\nvar _composeSignals = _interopRequireDefault(require(\"../helpers/composeSignals.js\"));\nvar _trackStream = require(\"../helpers/trackStream.js\");\nvar _AxiosHeaders = _interopRequireDefault(require(\"../core/AxiosHeaders.js\"));\nvar _progressEventReducer = require(\"../helpers/progressEventReducer.js\");\nvar _resolveConfig = _interopRequireDefault(require(\"../helpers/resolveConfig.js\"));\nvar _settle = _interopRequireDefault(require(\"../core/settle.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst {\n  isFunction\n} = _utils.default;\nconst globalFetchAPI = (({\n  Request,\n  Response\n}) => ({\n  Request,\n  Response\n}))(_utils.default.global);\nconst {\n  ReadableStream,\n  TextEncoder\n} = _utils.default.global;\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false;\n  }\n};\nconst factory = env => {\n  env = _utils.default.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n  const {\n    fetch: envFetch,\n    Request,\n    Response\n  } = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n  if (!isFetchSupported) {\n    return false;\n  }\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : async str => new Uint8Array(await new Request(str).arrayBuffer()));\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n    const hasContentType = new Request(_index.default.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      }\n    }).headers.has('Content-Type');\n    return duplexAccessed && !hasContentType;\n  });\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => _utils.default.isReadableStream(new Response('').body));\n  const resolvers = {\n    stream: supportsResponseStream && (res => res.body)\n  };\n  isFetchSupported && (() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n        if (method) {\n          return method.call(res);\n        }\n        throw new _AxiosError.default(`Response type '${type}' is not supported`, _AxiosError.default.ERR_NOT_SUPPORT, config);\n      });\n    });\n  })();\n  const getBodyLength = async body => {\n    if (body == null) {\n      return 0;\n    }\n    if (_utils.default.isBlob(body)) {\n      return body.size;\n    }\n    if (_utils.default.isSpecCompliantForm(body)) {\n      const _request = new Request(_index.default.origin, {\n        method: 'POST',\n        body\n      });\n      return (await _request.arrayBuffer()).byteLength;\n    }\n    if (_utils.default.isArrayBufferView(body) || _utils.default.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n    if (_utils.default.isURLSearchParams(body)) {\n      body = body + '';\n    }\n    if (_utils.default.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  };\n  const resolveBodyLength = async (headers, body) => {\n    const length = _utils.default.toFiniteNumber(headers.getContentLength());\n    return length == null ? getBodyLength(body) : length;\n  };\n  return async config => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = (0, _resolveConfig.default)(config);\n    let _fetch = envFetch || fetch;\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n    let composedSignal = (0, _composeSignals.default)([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n    let request = null;\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n    let requestContentLength;\n    try {\n      if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n        let contentTypeHeader;\n        if (_utils.default.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader);\n        }\n        if (_request.body) {\n          const [onProgress, flush] = (0, _progressEventReducer.progressEventDecorator)(requestContentLength, (0, _progressEventReducer.progressEventReducer)((0, _progressEventReducer.asyncDecorator)(onUploadProgress)));\n          data = (0, _trackStream.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n      if (!_utils.default.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      }\n\n      // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n      const resolvedOptions = {\n        ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n      request = isRequestSupported && new Request(url, resolvedOptions);\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n        const options = {};\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n        const responseContentLength = _utils.default.toFiniteNumber(response.headers.get('content-length'));\n        const [onProgress, flush] = onDownloadProgress && (0, _progressEventReducer.progressEventDecorator)(responseContentLength, (0, _progressEventReducer.progressEventReducer)((0, _progressEventReducer.asyncDecorator)(onDownloadProgress), true)) || [];\n        response = new Response((0, _trackStream.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n          flush && flush();\n          unsubscribe && unsubscribe();\n        }), options);\n      }\n      responseType = responseType || 'text';\n      let responseData = await resolvers[_utils.default.findKey(resolvers, responseType) || 'text'](response, config);\n      !isStreamResponse && unsubscribe && unsubscribe();\n      return await new Promise((resolve, reject) => {\n        (0, _settle.default)(resolve, reject, {\n          data: responseData,\n          headers: _AxiosHeaders.default.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        });\n      });\n    } catch (err) {\n      unsubscribe && unsubscribe();\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(new _AxiosError.default('Network Error', _AxiosError.default.ERR_NETWORK, config, request), {\n          cause: err.cause || err\n        });\n      }\n      throw _AxiosError.default.from(err, err && err.code, config, request);\n    }\n  };\n};\nconst seedCache = new Map();\nconst getFetch = config => {\n  let env = config && config.env || {};\n  const {\n    fetch,\n    Request,\n    Response\n  } = env;\n  const seeds = [Request, Response, fetch];\n  let len = seeds.length,\n    i = len,\n    seed,\n    target,\n    map = seedCache;\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n    target === undefined && map.set(seed, target = i ? new Map() : factory(env));\n    map = target;\n  }\n  return target;\n};\nexports.getFetch = getFetch;\nconst adapter = getFetch();\nvar _default = exports.default = adapter;"},"sourceMaps":null,"error":null,"hash":"793f70c6229a3712b8f27a7fda165290","cacheData":{"env":{}}}